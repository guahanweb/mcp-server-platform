{"version":3,"sources":["../src/index.ts","../src/session-manager.ts","../src/context-manager.ts","../src/workflow-registry.ts","../src/intent-detector.ts","../src/stores/memory-store.ts","../src/stores/redis-store.ts","../src/orchestrator.ts"],"sourcesContent":["export * from './orchestrator';\nexport * from './session-manager';\nexport * from './context-manager';\nexport * from './intent-detector';\nexport * from './workflow-registry';\nexport * from './stores';","import { UserSession, ConversationEntry, SessionStore } from '@mcp/types';\n\nexport class SessionManager {\n  private store: SessionStore;\n  private sessionTimeout: number;\n\n  constructor(store: SessionStore, sessionTimeout: number = 30 * 60 * 1000) { // 30 minutes default\n    this.store = store;\n    this.sessionTimeout = sessionTimeout;\n  }\n\n  async createSession(userId: string, userName: string, sessionId?: string): Promise<UserSession> {\n    const session: UserSession = {\n      sessionId: sessionId || this.generateSessionId(),\n      userId,\n      userName,\n      currentContext: 'general',\n      globalContext: {\n        userId,\n        userName,\n        preferences: {},\n        activeProjects: [],\n        recentWorkflows: []\n      },\n      conversationHistory: [],\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    await this.store.set(session);\n    return session;\n  }\n\n  async getSession(sessionId: string): Promise<UserSession | null> {\n    return this.store.get(sessionId);\n  }\n\n  async getOrCreateSession(sessionId: string | undefined, userId: string, userName: string): Promise<UserSession> {\n    if (sessionId) {\n      const existing = await this.getSession(sessionId);\n      if (existing) {\n        return existing;\n      }\n    }\n    return this.createSession(userId, userName, sessionId);\n  }\n\n  async updateSession(session: UserSession): Promise<void> {\n    session.updatedAt = new Date();\n    await this.store.set(session);\n  }\n\n  async deleteSession(sessionId: string): Promise<boolean> {\n    const exists = await this.store.exists(sessionId);\n    if (exists) {\n      await this.store.delete(sessionId);\n      return true;\n    }\n    return false;\n  }\n\n  async addMessage(sessionId: string, message: ConversationEntry): Promise<void> {\n    const session = await this.getSession(sessionId);\n    if (session) {\n      session.conversationHistory.push(message);\n      await this.updateSession(session);\n    }\n  }\n\n  async getStats(): Promise<{\n    totalSessions: number;\n    activeSessions: number;\n    averageSessionDuration: number;\n    topWorkflows: Array<{ workflow: string; count: number }>;\n  }> {\n    // This would need implementation in the session store\n    return {\n      totalSessions: 0,\n      activeSessions: 0,\n      averageSessionDuration: 0,\n      topWorkflows: []\n    };\n  }\n\n  async cleanup(): Promise<number> {\n    const cutoffTime = new Date(Date.now() - this.sessionTimeout);\n    if (this.store.cleanup) {\n      return this.store.cleanup(cutoffTime);\n    }\n    return 0;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","import { UserSession, WorkflowContext, ContextLoader } from '@mcp/types';\nimport { WorkflowRegistry } from './workflow-registry';\n\nexport class ContextManager {\n  private registry: WorkflowRegistry;\n  private loaders: Map<string, ContextLoader> = new Map();\n\n  constructor(registry: WorkflowRegistry) {\n    this.registry = registry;\n  }\n\n  registerLoader(workflowId: string, loader: ContextLoader): void {\n    this.loaders.set(workflowId, loader);\n  }\n\n  async switchContext(\n    session: UserSession,\n    targetWorkflow: string | undefined,\n    initData?: any\n  ): Promise<UserSession> {\n    if (!targetWorkflow) {\n      // Switch to general context\n      session.activeWorkflow = undefined;\n      session.workflowContext = undefined;\n      session.currentContext = 'general';\n      return session;\n    }\n\n    const workflow = this.registry.get(targetWorkflow);\n    if (!workflow) {\n      throw new Error(`Workflow not found: ${targetWorkflow}`);\n    }\n\n    // Load workflow context\n    const loader = this.loaders.get(targetWorkflow);\n    if (loader) {\n      session.workflowContext = await loader.loadContext(targetWorkflow, session.sessionId);\n    } else {\n      // Create basic context\n      session.workflowContext = {\n        workflowId: targetWorkflow,\n        state: {\n          workflowId: targetWorkflow,\n          currentStep: 'initial',\n          data: initData || {},\n          metadata: {\n            startedAt: new Date(),\n            lastModified: new Date(),\n            completionPercentage: 0,\n            isDraft: true\n          },\n          checkpoints: []\n        },\n        hydratedData: {},\n        tools: workflow.capabilities || [],\n        history: [],\n        checkpoints: []\n      };\n    }\n\n    session.activeWorkflow = targetWorkflow;\n    session.currentContext = targetWorkflow;\n\n    // Update recent workflows\n    if (!session.globalContext.recentWorkflows) {\n      session.globalContext.recentWorkflows = [];\n    }\n    \n    const recent = session.globalContext.recentWorkflows;\n    const index = recent.indexOf(targetWorkflow);\n    if (index > -1) {\n      recent.splice(index, 1);\n    }\n    recent.unshift(targetWorkflow);\n    \n    // Keep only last 10\n    if (recent.length > 10) {\n      recent.splice(10);\n    }\n\n    return session;\n  }\n\n  updateWorkflowProgress(\n    session: UserSession,\n    step: string,\n    percentage: number\n  ): UserSession {\n    if (session.workflowContext) {\n      session.workflowContext.state.currentStep = step;\n      session.workflowContext.state.metadata.completionPercentage = percentage;\n      session.workflowContext.state.metadata.lastModified = new Date();\n\n      // Add to history\n      session.workflowContext.history.push({\n        timestamp: new Date(),\n        action: 'progress_update',\n        details: { step, percentage }\n      });\n    }\n\n    return session;\n  }\n\n  addWorkflowCheckpoint(\n    session: UserSession,\n    description?: string,\n    data?: any\n  ): UserSession {\n    if (session.workflowContext) {\n      const checkpoint = {\n        id: `checkpoint_${Date.now()}`,\n        timestamp: new Date(),\n        step: session.workflowContext.state.currentStep,\n        description: description || `Checkpoint at ${session.workflowContext.state.currentStep}`,\n        data: data || {}\n      };\n\n      session.workflowContext.state.checkpoints.push(checkpoint);\n      session.workflowContext.checkpoints.push(checkpoint);\n\n      // Add to history\n      session.workflowContext.history.push({\n        timestamp: new Date(),\n        action: 'checkpoint_added',\n        details: { checkpointId: checkpoint.id, description }\n      });\n    }\n\n    return session;\n  }\n}","import { WorkflowDefinition } from '@mcp/types';\n\nexport class WorkflowRegistry {\n  private workflows: Map<string, WorkflowDefinition> = new Map();\n\n  register(definition: WorkflowDefinition): void {\n    this.workflows.set(definition.id, definition);\n  }\n\n  get(id: string): WorkflowDefinition | undefined {\n    return this.workflows.get(id);\n  }\n\n  getAll(): WorkflowDefinition[] {\n    return Array.from(this.workflows.values());\n  }\n\n  findByTrigger(trigger: string): WorkflowDefinition[] {\n    const lowerTrigger = trigger.toLowerCase();\n    return this.getAll().filter(workflow =>\n      workflow.triggers.some(t => t.toLowerCase().includes(lowerTrigger))\n    );\n  }\n\n  findByCategory(category: string): WorkflowDefinition[] {\n    return this.getAll().filter(workflow => workflow.category === category);\n  }\n\n  unregister(id: string): boolean {\n    return this.workflows.delete(id);\n  }\n\n  clear(): void {\n    this.workflows.clear();\n  }\n\n  has(id: string): boolean {\n    return this.workflows.has(id);\n  }\n\n  size(): number {\n    return this.workflows.size;\n  }\n}","import { IntentAnalysis, IntentDetector, UserSession } from '@mcp/types';\nimport { WorkflowRegistry } from './workflow-registry';\n\nexport class RuleBasedIntentDetector implements IntentDetector {\n  private registry: WorkflowRegistry;\n\n  constructor(registry: WorkflowRegistry) {\n    this.registry = registry;\n  }\n\n  async analyzeMessage(message: string, session: UserSession): Promise<IntentAnalysis> {\n    const lowerMessage = message.toLowerCase();\n    \n    // Check for exit signals first\n    const exitSignals = ['done', 'finished', 'complete', 'exit', 'stop', 'end session', 'quit'];\n    const shouldExit = exitSignals.some(signal => lowerMessage.includes(signal));\n    \n    if (shouldExit && session.activeWorkflow) {\n      return {\n        confidence: 0.9,\n        intents: [{\n          name: 'exit_workflow',\n          confidence: 0.9\n        }],\n        entities: [],\n        shouldSwitchWorkflow: true,\n        targetWorkflow: undefined, // Exit to general context\n        extractedData: { reason: 'user_requested' }\n      };\n    }\n\n    // Find matching workflows by triggers\n    const matchingWorkflows = this.registry.getAll().filter(workflow =>\n      workflow.triggers.some(trigger => lowerMessage.includes(trigger.toLowerCase()))\n    );\n\n    if (matchingWorkflows.length > 0) {\n      const bestMatch = matchingWorkflows[0]; // Simple: take first match\n      const confidence = this.calculateConfidence(message, bestMatch.triggers);\n      \n      return {\n        confidence,\n        intents: [{\n          name: 'switch_workflow',\n          confidence,\n          parameters: { targetWorkflow: bestMatch.id }\n        }],\n        entities: this.extractEntities(message),\n        shouldSwitchWorkflow: confidence > 0.7,\n        targetWorkflow: bestMatch.id,\n        extractedData: this.extractWorkflowData(message, bestMatch)\n      };\n    }\n\n    // No workflow switch needed\n    return {\n      confidence: 0.1,\n      intents: [{\n        name: 'continue_current',\n        confidence: 0.1\n      }],\n      entities: this.extractEntities(message),\n      shouldSwitchWorkflow: false\n    };\n  }\n\n  private calculateConfidence(message: string, triggers: string[]): number {\n    const lowerMessage = message.toLowerCase();\n    let maxConfidence = 0;\n\n    for (const trigger of triggers) {\n      const lowerTrigger = trigger.toLowerCase();\n      \n      if (lowerMessage === lowerTrigger) {\n        maxConfidence = Math.max(maxConfidence, 1.0);\n      } else if (lowerMessage.includes(lowerTrigger)) {\n        const ratio = lowerTrigger.length / lowerMessage.length;\n        maxConfidence = Math.max(maxConfidence, ratio * 0.8);\n      } else if (this.fuzzyMatch(lowerMessage, lowerTrigger)) {\n        maxConfidence = Math.max(maxConfidence, 0.6);\n      }\n    }\n\n    return maxConfidence;\n  }\n\n  private fuzzyMatch(text: string, pattern: string): boolean {\n    const words = pattern.split(' ');\n    return words.every(word => text.includes(word));\n  }\n\n  private extractEntities(message: string) {\n    const entities = [];\n    \n    // Extract emails\n    const emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g;\n    const emails = message.match(emailRegex);\n    if (emails) {\n      entities.push(...emails.map(email => ({\n        type: 'email',\n        value: email,\n        confidence: 1.0\n      })));\n    }\n\n    // Extract numbers\n    const numberRegex = /\\b\\d+(?:\\.\\d+)?\\b/g;\n    const numbers = message.match(numberRegex);\n    if (numbers) {\n      entities.push(...numbers.map(num => ({\n        type: 'number',\n        value: num,\n        confidence: 1.0\n      })));\n    }\n\n    // Extract URLs\n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n    const urls = message.match(urlRegex);\n    if (urls) {\n      entities.push(...urls.map(url => ({\n        type: 'url',\n        value: url,\n        confidence: 1.0\n      })));\n    }\n\n    return entities;\n  }\n\n  private extractWorkflowData(message: string, workflow: any): Record<string, any> {\n    const data: Record<string, any> = {\n      originalMessage: message,\n      workflowId: workflow.id,\n      timestamp: new Date().toISOString()\n    };\n\n    // Extract basic context based on workflow type\n    if (workflow.id.includes('character')) {\n      const nameMatch = message.match(/(?:character|person|character named|called)\\s+([A-Z][a-z]+)/i);\n      if (nameMatch) {\n        data.characterName = nameMatch[1];\n      }\n    }\n\n    if (workflow.id.includes('story')) {\n      const genreMatch = message.match(/(?:story|tale|novel|book)\\s+(?:about|involving|featuring)\\s+([^.!?]+)/i);\n      if (genreMatch) {\n        data.storyTopic = genreMatch[1].trim();\n      }\n    }\n\n    return data;\n  }\n}","import { SessionStore, UserSession } from '@mcp/types';\n\nexport class InMemorySessionStore implements SessionStore {\n  private sessions: Map<string, UserSession> = new Map();\n\n  async get(sessionId: string): Promise<UserSession | null> {\n    return this.sessions.get(sessionId) || null;\n  }\n\n  async set(session: UserSession): Promise<void> {\n    this.sessions.set(session.sessionId, { ...session });\n  }\n\n  async delete(sessionId: string): Promise<void> {\n    this.sessions.delete(sessionId);\n  }\n\n  async exists(sessionId: string): Promise<boolean> {\n    return this.sessions.has(sessionId);\n  }\n\n  async cleanup(olderThan: Date): Promise<number> {\n    let cleaned = 0;\n    for (const [sessionId, session] of this.sessions) {\n      if (session.updatedAt < olderThan) {\n        this.sessions.delete(sessionId);\n        cleaned++;\n      }\n    }\n    return cleaned;\n  }\n\n  // Additional methods for testing/debugging\n  clear(): void {\n    this.sessions.clear();\n  }\n\n  size(): number {\n    return this.sessions.size;\n  }\n\n  getAll(): UserSession[] {\n    return Array.from(this.sessions.values());\n  }\n}","import { SessionStore, UserSession } from '@mcp/types';\n\nexport interface RedisConfig {\n  host?: string;\n  port?: number;\n  password?: string;\n  db?: number;\n  keyPrefix?: string;\n  ttl?: number; // TTL in seconds\n}\n\nexport class RedisSessionStore implements SessionStore {\n  private config: RedisConfig;\n  private keyPrefix: string;\n  private ttl: number;\n\n  constructor(config: RedisConfig = {}) {\n    this.config = {\n      host: 'localhost',\n      port: 6379,\n      keyPrefix: 'mcp:session:',\n      ttl: 1800, // 30 minutes\n      ...config\n    };\n    this.keyPrefix = this.config.keyPrefix!;\n    this.ttl = this.config.ttl!;\n  }\n\n  private getKey(sessionId: string): string {\n    return `${this.keyPrefix}${sessionId}`;\n  }\n\n  async get(sessionId: string): Promise<UserSession | null> {\n    // This would require a Redis client implementation\n    // For now, this is a placeholder that would integrate with redis/ioredis\n    throw new Error('RedisSessionStore requires Redis client implementation');\n  }\n\n  async set(session: UserSession): Promise<void> {\n    // This would serialize the session and store it in Redis with TTL\n    throw new Error('RedisSessionStore requires Redis client implementation');\n  }\n\n  async delete(sessionId: string): Promise<void> {\n    // This would delete the key from Redis\n    throw new Error('RedisSessionStore requires Redis client implementation');\n  }\n\n  async exists(sessionId: string): Promise<boolean> {\n    // This would check if the key exists in Redis\n    throw new Error('RedisSessionStore requires Redis client implementation');\n  }\n\n  async cleanup(olderThan: Date): Promise<number> {\n    // Redis TTL handles cleanup automatically\n    // This could scan for expired keys if needed\n    return 0;\n  }\n\n  // Example implementation structure (would need actual Redis client):\n  /*\n  private redis: Redis;\n\n  constructor(config: RedisConfig = {}) {\n    this.config = { ... };\n    this.redis = new Redis(this.config);\n  }\n\n  async get(sessionId: string): Promise<UserSession | null> {\n    const data = await this.redis.get(this.getKey(sessionId));\n    return data ? JSON.parse(data) : null;\n  }\n\n  async set(session: UserSession): Promise<void> {\n    const key = this.getKey(session.sessionId);\n    const data = JSON.stringify(session);\n    await this.redis.setex(key, this.ttl, data);\n  }\n\n  async delete(sessionId: string): Promise<void> {\n    await this.redis.del(this.getKey(sessionId));\n  }\n\n  async exists(sessionId: string): Promise<boolean> {\n    const result = await this.redis.exists(this.getKey(sessionId));\n    return result === 1;\n  }\n  */\n}","import { \n  UserSession,\n  IntentAnalysis,\n  WorkflowDefinition,\n  OrchestrationConfig,\n  SessionStore,\n  IntentDetector,\n  ContextLoader\n} from '@mcp/types';\nimport { SessionManager } from './session-manager';\nimport { ContextManager } from './context-manager';\nimport { WorkflowRegistry } from './workflow-registry';\nimport { RuleBasedIntentDetector } from './intent-detector';\nimport { InMemorySessionStore } from './stores';\n\nexport class Orchestrator {\n  private sessionManager: SessionManager;\n  private contextManager: ContextManager;\n  private workflowRegistry: WorkflowRegistry;\n  private intentDetector: IntentDetector;\n\n  constructor(config: OrchestrationConfig = {}) {\n    // Initialize components\n    this.workflowRegistry = new WorkflowRegistry();\n    this.contextManager = new ContextManager(this.workflowRegistry);\n    \n    // Use provided or default implementations\n    const sessionStore = config.sessionStore || new InMemorySessionStore();\n    this.sessionManager = new SessionManager(sessionStore, config.sessionTimeout);\n    \n    this.intentDetector = config.intentDetector || new RuleBasedIntentDetector(this.workflowRegistry);\n  }\n\n  // Workflow registration\n  registerWorkflow(definition: WorkflowDefinition): void {\n    this.workflowRegistry.register(definition);\n  }\n\n  getRegisteredWorkflows(): WorkflowDefinition[] {\n    return this.workflowRegistry.getAll();\n  }\n\n  // Context management\n  registerContextLoader(workflowId: string, loader: ContextLoader): void {\n    this.contextManager.registerLoader(workflowId, loader);\n  }\n\n  // Main message processing\n  async processMessage(\n    message: string,\n    sessionId?: string,\n    userId: string = 'default-user',\n    userName: string = 'User'\n  ): Promise<{\n    session: UserSession;\n    intent: IntentAnalysis;\n    workflowChanged: boolean;\n  }> {\n    // Load or create session\n    const session = await this.sessionManager.getOrCreateSession(\n      sessionId,\n      userId,\n      userName\n    );\n\n    // Add message to conversation history\n    await this.sessionManager.addMessage(session.sessionId, {\n      id: `msg_${Date.now()}`,\n      timestamp: new Date(),\n      role: 'user',\n      content: message\n    });\n\n    // Analyze intent\n    const intent = await this.intentDetector.analyzeMessage(message, session);\n\n    // Handle context switching if needed\n    let workflowChanged = false;\n    if (intent.shouldSwitchWorkflow && intent.targetWorkflow) {\n      await this.contextManager.switchContext(\n        session,\n        intent.targetWorkflow,\n        intent.extractedData\n      );\n      workflowChanged = true;\n    }\n\n    // Update session\n    await this.sessionManager.updateSession(session);\n\n    return {\n      session,\n      intent,\n      workflowChanged,\n    };\n  }\n\n  // Session management\n  async getSession(sessionId: string): Promise<UserSession | null> {\n    return this.sessionManager.getSession(sessionId);\n  }\n\n  async createSession(userId: string, userName: string, sessionId?: string): Promise<UserSession> {\n    return this.sessionManager.createSession(userId, userName, sessionId);\n  }\n\n  async updateSession(session: UserSession): Promise<void> {\n    return this.sessionManager.updateSession(session);\n  }\n\n  async deleteSession(sessionId: string): Promise<boolean> {\n    return this.sessionManager.deleteSession(sessionId);\n  }\n\n  async addMessage(sessionId: string, role: 'user' | 'assistant' | 'system', content: string): Promise<void> {\n    await this.sessionManager.addMessage(sessionId, {\n      id: `msg_${Date.now()}`,\n      timestamp: new Date(),\n      role,\n      content\n    });\n  }\n\n  // Context switching\n  async switchWorkflow(\n    sessionId: string,\n    targetWorkflow: string | undefined,\n    initData?: any\n  ): Promise<UserSession> {\n    const session = await this.sessionManager.getSession(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    await this.contextManager.switchContext(session, targetWorkflow, initData);\n    await this.sessionManager.updateSession(session);\n    \n    return session;\n  }\n\n  // Workflow state management\n  async updateWorkflowProgress(\n    sessionId: string,\n    step: string,\n    percentage: number\n  ): Promise<void> {\n    const session = await this.sessionManager.getSession(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    this.contextManager.updateWorkflowProgress(session, step, percentage);\n    await this.sessionManager.updateSession(session);\n  }\n\n  async addWorkflowCheckpoint(\n    sessionId: string,\n    description?: string,\n    data?: any\n  ): Promise<void> {\n    const session = await this.sessionManager.getSession(sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n\n    this.contextManager.addWorkflowCheckpoint(session, description, data);\n    await this.sessionManager.updateSession(session);\n  }\n\n  // Analytics and monitoring\n  async getSessionStats(): Promise<{\n    totalSessions: number;\n    activeSessions: number;\n    averageSessionDuration: number;\n    topWorkflows: Array<{ workflow: string; count: number }>;\n  }> {\n    return this.sessionManager.getStats();\n  }\n\n  async cleanupExpiredSessions(): Promise<number> {\n    return this.sessionManager.cleanup();\n  }\n\n  // Health check\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    components: {\n      sessionStore: boolean;\n      workflowRegistry: boolean;\n      contextManager: boolean;\n      intentDetector: boolean;\n    };\n    metrics: {\n      activeSessions: number;\n      registeredWorkflows: number;\n      uptime: number;\n    };\n  }> {\n    const components = {\n      sessionStore: true, // TODO: Add health check to session store\n      workflowRegistry: this.workflowRegistry.getAll().length > 0,\n      contextManager: true, // TODO: Add health check to context manager\n      intentDetector: true, // TODO: Add health check to intent detector\n    };\n\n    const allHealthy = Object.values(components).every(Boolean);\n    const status = allHealthy ? 'healthy' : 'degraded';\n\n    const stats = await this.getSessionStats();\n\n    return {\n      status,\n      components,\n      metrics: {\n        activeSessions: stats.activeSessions,\n        registeredWorkflows: this.workflowRegistry.getAll().length,\n        uptime: process.uptime() * 1000, // Convert to milliseconds\n      },\n    };\n  }\n\n  // Utility methods for testing/debugging\n  getWorkflowRegistry(): WorkflowRegistry {\n    return this.workflowRegistry;\n  }\n\n  getContextManager(): ContextManager {\n    return this.contextManager;\n  }\n\n  getSessionManager(): SessionManager {\n    return this.sessionManager;\n  }\n\n  getIntentDetector(): IntentDetector {\n    return this.intentDetector;\n  }\n}"],"mappings":"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","names":[]}